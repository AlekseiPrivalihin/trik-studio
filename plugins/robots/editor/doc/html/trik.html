<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="keywords" content="TRIKStudio, help, manual, user guide" />
<meta name="description" content="TRIKStudio help center" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>Программирование ТРИК в TRIKStudio</title>
<link href="style.css" rel="stylesheet" type="text/css" media="screen" />
<script type="text/javascript" src="version.js"></script>
</head>

<!-- TODO: move contents, header and footer into common separate files -->
<body>
<div id="wrapper">
	<script type="text/javascript" src="header.html.js"></script>
	<div id="page" class="container">
		<div id="sidebar">
			<script type="text/javascript" src="contents.html.js"></script>
		</div>		
		<div id="content">
			<div class="post">
				<h2 class="title">Программирование контроллера ТРИК в TRIKStudio<a href="#"></a></h2>
				<div class="entry">
					<p></p>
				</div>
			</div>
			
			<h3><a name="connection">Подключение робота</a></h3>

			<p>
			Подробная инструкция по настройке и подключению робота к сети находится на вики проекта, <a href="https://github.com/trikset/trikRuntime/wiki/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B5-%D0%B8-%D0%BF%D0%BE%D0%B4%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D1%8E-%D0%BA-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D1%83">Инструкция по настройке и подсоединению к контроллеру</a>. Здесь будем считать, что робот и компьютер с TRIKStudio уже находятся в одной сети. В таком случае достаточно выбрать конструктор ТРИК в окне настроек и указать IP-адрес робота (его можно посмотреть в меню "Сеть" на роботе):
			</p>
			
			<center><img src="pics/trik-kit-selection.png" alt="Выбор конструктора ТРИК" width="660"></center>
			
			<p> 
			Указать IP-адрес робота можно и в окне конфигурации сенсоров прямо на главном окне TRIKStudio:
			</p>

			<center><img src="pics/trik-fast-ip-selection.png" alt="Быстрый выбор IP-адреса"></center>

			<p> 
			Этих действий достаточно для работы с ТРИК в режиме генерации, для работы интерпретатора необходимо ещё установить соединение с роботом, нажав на кнопку "Подключиться" на панели инструментов:
			</p>

			<center><img src="pics/trik-connect.png" alt="Кнопка 'Подключиться'" width="660"></center>
			
			<h3><a name="blocks">Блоки ТРИК</a></h3>
			
			<p>
			Специализированные блоки для ТРИК делятся на несколько категорий:
			</p>

			<ul>
				<li><b><a href="#trik-functional-blocks">Действия</a></b> – блоки, выполняющие какое-либо действие на роботе: включение моторов, проигрывание звука и т.д.</li>
				<li><b><a href="#trik-waiting-blocks">Ожидания</a></b> – блоки, ждущие наступления какого-либо события: определённых показаний датчиков, нажатия на кнопку и т.д.</li> 
				<li><b><a href="#trik-drawing-blocks">Рисования на дисплее</a></b> – блоки, используемые для вывода графики и текста на экран.</li>
			</ul>

			<h4><a name="trik-functional-blocks">Действия</a></h4>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название элемента</b></td>
					<td><b>Пиктограмма</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>Играть звук</td>
					<td><center><img src="pics/trik-playSoundBlock.png" alt="Гудок"></center></td>
					<td>Проиграть на роботе заданный звуковой файл, который должен быть заранее загружен на робот. Путь до файла указывается относительно папки trik на роботе. Загрузить файл на робот можно, например, с помощью программы <a href="http://winscp.net/eng/docs/lang:ru">WinSCP</a></td>
				</tr>
				<tr>
					<td>Моторы вперёд</td>
					<td><center><img src="pics/trik-enginesForwardBlock.png" alt="Моторы вперёд"></center></td>
					<td>Включить моторы по заданным портам с заданной мощностью. Порты задаются строками M1, M2, M3 и M4, разделенными запятыми. Мощность задается в процентах числом от -100 до 100, если задано отрицательное значение, мотор включается в режиме реверса. Так, на картинке изображена команда включения моторов на портах M3 и M4 с мощностью 100%.
					</td>
				</tr>
				<tr>
					<td>Моторы назад</td>
					<td><center><img src="pics/trik-enginesBackwardBlock.png" alt="Моторы назад"></center></td>
					<td>Включить моторы в режиме реверса по заданным портам с заданной мощностью. Параметры аналогичны параметрами блока "Моторы вперёд".</td>
				</tr>
				<tr>
					<td>Моторы стоп</td>
					<td><center><img src="pics/trik-enginesStopBlock.png" alt="Моторы стоп"></center></td>
					<td>Выключить моторы по заданным портам.</td>
				</tr>
				<tr>
					<td>Сбросить показания энкодера</td>
					<td><center><img src="pics/trik-clearEncoderBlock.png" alt="Сбросить показания энкодера"></center></td>
					<td>Сбросить показания количества оборотов моторов по указанным портам.</td>
				</tr>
				<tr>
					<td>Угловой сервомотор</td>
					<td><center><img src="pics/trik-angularServoBlock.png" alt="Угловой сервомотор"></center></td>
					<td>Установить валы угловых сервомоторов на указанных портах в указанное положение (в градусах, от -90 до 90).</td>
				</tr>
				<tr>
					<td>Сказать</td>
					<td><center><img src="pics/trik-sayBlock.png" alt="Сказать"></center></td>
					<td>Произнести с помощью динамика фразу, переданную в качестве аргумента блока.</td>
				</tr>
				<tr>
					<td>Светодиод</td>
					<td><center><img src="pics/trik-ledBlock.png" alt="Светодиод"></center></td>
					<td>Установить цвет светодиода на корпусе робота в указанный.</td>
				</tr>
				<tr>
					<td>Системный вызов</td>
					<td><center><img src="pics/trik-systemBlock.png" alt="Системный вызов"></center></td>
					<td>Блок имеет булевый параметр "Код". Если он установлен в "Истина", содержимое параметра "Команда" генерируется напрямую в текст программы при генерации этого блока. Если он установлен в "Ложь", генерируется вызов консольной команды операционной системы. Например, команда, представленная на рисунке, перезагружает робот.</td>
				</tr>
				<tr>
					<td>Включить видеокамеру</td>
					<td><center><img src="pics/trik-cameraOnBlock.png" alt="Включить видеокамеру"></center></td>
					<td>Включить видеокамеру на роботе в одном из трёх режимов:
						<ol>
							<li><b>Сенсор линии</b> – детектирует цветную линию в центре кадра и в дальнейшем возвращает отклонение центра линии от центра кадра, как число в интервале от -100 (влево) до 100 (вправо).</li>
							<li><b>Сенсор объекта</b> – детектирует контрастный объект в центре кадра и в дальнейшем возвращает координаты его центра и диаметр в пикселах.</li>
							<li><b>Сенсор цвета</b> – возвращает доминирующий цвет в центре кадра в виде его координат в цветовой шкале RGB.</li>
						</ol>
					</td>
				</tr>
				<tr>
					<td>Детектировать по камере</td>
					<td><center><img src="pics/trik-cameraDetectBlock.png" alt="Детектировать по камере"></center></td>
					<td>Фиксирует изображение в центре кадра и инициализирует им датчик линии или датчик объекта. Камера должна быть включена в соответствующем режиме блоком "Включить видеокамеру"</td>
				</tr>
				<tr>
					<td>Значение детектора в переменную</td>
					<td><center><img src="pics/trik-detectorToVariableBlock.png" alt="Значение детектора в переменную"></center></td>
					<td>Помещает текущее показание датчика линии в указанную переменную. Камера должна быть включена в режиме датчика линии блоком "Включить видеокамеру" и проинициализирована блоком "Детектировать по камере"</td>
				</tr>
				<tr>
					<td>Послать сообщение</td>
					<td><center><img src="pics/trik-sendMessageBlock.png" alt="Послать сообщение"></center></td>
					<td>Отправляет данное сообщение роботу с данным бортовым номером. Робот должен быть в той же сети, что и робот, отправляющий сообщение, и зарегистрирован как ведущий или ведомый с помощью меню "Настройки" -> "Сообщения" на роботе. Если роботов с данным бортовым номером в сети несколько, сообщение получат все они.</td>
				</tr>
			</table>

			<h4><a name="trik-waiting-blocks">Ожидания</a></h4>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название элемента</b></td>
					<td><b>Пиктограмма</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>Ждать свет</td>
					<td><center><img src="pics/trik-waitLightBlock.png" alt="Ждать свет"></center></td>
					<td>Ждать, пока значение, возвращаемое сенсором света на указанном порту, не будет сравнимо с указанным в значении параметра "Проценты". Еще один парамер — номер порта, к которому подключен сенсор цвета. Также параметром указывается операция, которая будет использоваться для сравнения со значением параметра "Проценты". Так, при выполнении приведенного блока выполнение программы остановится до тех пор, пока значение, возвращаемое соответствующим сенсором света, не будет больше, чем 60 процентов.</td>
				</tr>
				<tr>
					<td>Ждать УЗ датчик расстояния</td>
					<td><center><img src="pics/trik-waitForSonarDistance.png" alt="Ждать УЗ датчик расстояния"></center></td>
					<td>Ждать, пока расстояние, возвращаемое ультразвуковым сенсором расстояния, не будет сравнимо с указанным в значении параметра "Расстояние" (расстояние задается в сантиметрах, от 0 до 255). Еще один парамер — номер порта, к которому подключен датчик расстояния. Также параметром указывается операция, которая будет использоваться для сравнения с введенным расстоянием. Так, при выполнении приведенного блока выполнение программы остановится до тех пор, пока значение, возвращаемое сонаром, не будет больше, чем 40 см.</td>
				</tr>
				<tr>
					<td>Ждать ИК датчик расстояния</td>
					<td><center><img src="pics/trik-waitForIRDistance.png" alt="Ждать ИК датчик расстояния"></center></td>
					<td>Ждать, пока расстояние, возвращаемое инфракрасным сенсором расстояния, не будет сравнимо с указанным в значении параметра "Расстояние" (расстояние задается в сантиметрах, от 0 до 100). Еще один парамер — номер порта, к которому подключен датчик расстояния. Также параметром указывается операция, которая будет использоваться для сравнения с введенным расстоянием. Так, при выполнении приведенного блока выполнение программы остановится до тех пор, пока значение, возвращаемое сонаром, не будет больше, чем 40 см.</td>
				</tr>
				<tr>
					<td>Ждать движения</td>
					<td><center><img src="pics/trik-waitForMotion.png" alt="Ждать движения"></center></td>
					<td>Ждать, пока сенсор движения не зафиксирует движение.</td>
				</tr>				
				<tr>
					<td>Ждать энкодер</td>
					<td><center><img src="pics/trik-waitForEncoder.png" alt="Ждать энкодер"></center></td>
					<td>Ждать, пока показания счетчика количества оборотов на заданном порту не станут больше или меньше указанного в значении параметра "Предел оборотов".</td>
				</tr>
				<tr>
					<td>Ждать нажатия кнопки "Ввод"</td>
					<td><center><img src="pics/trik-waitForEnter.png" alt="Ждать нажатия кнопки 'Ввод'"></center></td>
					<td>Ждать, пока не будет нажата кнопка "Ввод" на корпусе робота.</td>
				</tr>
				<tr>
					<td>Ждать нажатия кнопки "Влево"</td>
					<td><center><img src="pics/trik-waitForLeft.png" alt="Ждать нажатия кнопки 'Влево'"></center></td>
					<td>Ждать, пока не будет нажата кнопка "Влево" на корпусе робота.</td>
				</tr>
				<tr>
					<td>Ждать нажатия кнопки "Вправо"</td>
					<td><center><img src="pics/trik-waitForRight.png" alt="Ждать нажатия кнопки 'Вправо'"></center></td>
					<td>Ждать, пока не будет нажата кнопка "Вправо" на корпусе робота.</td>
				</tr>
				<tr>
					<td>Ждать нажатия кнопки "Вниз"</td>
					<td><center><img src="pics/trik-waitForDown.png" alt="Ждать нажатия кнопки 'Вниз'"></center></td>
					<td>Ждать, пока не будет нажата кнопка "Вниз" на корпусе робота.</td>
				</tr>
				<tr>
					<td>Ждать нажатия кнопки "Вверх"</td>
					<td><center><img src="pics/trik-waitForUp.png" alt="Ждать нажатия кнопки 'Вверх'"></center></td>
					<td>Ждать, пока не будет нажата кнопка "Вверх" на корпусе робота.</td>
				</tr>
				<tr>
					<td>Ждать нажатия кнопки "Питание"</td>
					<td><center><img src="pics/trik-waitForPower.png" alt="Ждать нажатия кнопки 'Питание'"></center></td>
					<td>Ждать, пока не будет нажата кнопка "Питание" на корпусе робота.</td>
				</tr>
				<tr>
					<td>Ждать сообщения</td>
					<td><center><img src="pics/trik-waitForMessage.png" alt="Ждать сообщения"></center></td>
					<td>Ждать получения сообщения через систему почтовых ящиков. Когда сообщение будет получено, оно будет помещено в указанную в параметре блока переменную.</td>
				</tr>					
			</table>

			<h4><a name="trik-drawing-blocks">Рисование на дисплее</a></h4>
			
			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название элемента</b></td>
					<td><b>Пиктограмма</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>Цвет кисти</td>
					<td><center><img src="pics/trik-setPainterColor.png" alt="Цвет кисти"></center></td>
					<td>Указать цвет, которым будут рисоваться простые графические фигуры на экране робота.</td>
				</tr>
				<tr>
					<td>Ширина кисти</td>
					<td><center><img src="pics/trik-setPainterWidth.png" alt="Ширина кисти"></center></td>
					<td>Указать ширину линии, которой будут рисоваться простые графические фигуры на экране робота.</td>
				</tr>
				<tr>
					<td>Нарисовать точку</td>
					<td><center><img src="pics/trik-drawPoint.png" alt="Нарисовать точку"></center></td>
					<td>Нарисовать на экране точку в указанных координатах.</td>
				</tr>
				<tr>
					<td>Нарисовать линию</td>
					<td><center><img src="pics/trik-drawLine.png" alt="Нарисовать линию"></center></td>
					<td>Нарисовать на экране отрезок. В качестве параметров блоку указываются концы отрезка.</td>
				</tr>
				<tr>
					<td>Нарисовать прямоугольник</td>
					<td><center><img src="pics/trik-drawRect.png" alt="Нарисовать прямоугольник"></center></td>
					<td>Нарисовать на экране прямоугольник. В качестве параметров указываются координаты левого верхнего угла, ширина и высота прямоугольника.</td>
				</tr>
				<tr>
					<td>Нарисовать эллипс</td>
					<td><center><img src="pics/trik-drawEllipse.png" alt="Нарисовать эллипс"></center></td>
					<td>Нарисовать на экране эллипс, вписанный в заданный прямоугольник.</td>
				</tr>
				<tr>
					<td>Нарисовать дугу</td>
					<td><center><img src="pics/trik-drawArc.png" alt="Нарисовать дугу"></center></td>
					<td>Нарисовать на экране дугу, задающуюся координатами прямоугольника, в который она будет вписана, и углами (в градусах) её начала и конца на окружности. Если начало и конец совпадают, будет нарисована полная окружность.</td>
				</tr>				
				<tr>
					<td>Смайлик</td>
					<td><center><img src="pics/trik-smile.png" alt="Смайлик"></center></td>
					<td>Нарисовать на экране смайлик.</td>
				</tr>	
				<tr>
					<td>Грустный смайлик</td>
					<td><center><img src="pics/trik-sadSmile.png" alt="Грустный смайлик"></center></td>
					<td>Нарисовать на экране грустный смайлик.</td>
				</tr>	
				<tr>
					<td>Цвет фона</td>
					<td><center><img src="pics/trik-setBackground.png" alt="Цвет фона"></center></td>
					<td>Задаёт цвет фона экрана.</td>
				</tr>
				<tr>
					<td>Напечатать текст</td>
					<td><center><img src="pics/nxt-displayTextBlock.png" alt="Напечатать текст"></center></td>
					<td>Напечатать заданное значение в заданных координатах на экране. Обратите внимание, что напечатается результат вычисления выражения, поэтому строки, которые нужно вывести на экран, надо заключать в кавычки.</td>
				</tr>
				<tr>
					<td>Очистить экран</td>
					<td><center><img src="pics/nxt-clearScreenBlock.png" alt="Очистить экран"></center></td>
					<td>Стереть всё, что нарисовано на экране.</td>
				</tr>
			</table>

			<p>
			Описание блоков, общих для всех конструкторов, можно посмотреть в разделе <a href="programming.html#blocks">Создание программ/Создание блоков</a>.
			</p>

			<h3><a name="textual-programming">Текстовое программирование</a></h3>
			<h4><a name="textual-programming-qts">Qt Script</a></h4>
			
			<p>
			Qt Script – интерпретируемый объектно-ориентированный язык с динамической типизацией, реализация стандарта ECMAScript (как и JavaScript, так что Qt Script можно рассматривать как диалект JavaScript). Подробное описание языка на русском можно найти, например, здесь: <a href="http://javascript.ru/ecma">http://javascript.ru/ecma</a>. При программировании на контроллере ТРИК используется библиотека, обеспечивающая взаимодействие скрипта с аппаратным обеспечением и некоторые расширения ECMAScript, описанные ниже.
			</p>
			
			<p>
			Пример простой программы на Qt Script:
			</p>
			
			<pre>
brick.smile();
brick.wait(2000);</pre>
			
			<p>
			Здесь мы видим объект <b>brick</b>, у которого вызываются два метода – <b>smile</b> (нарисовать смайлик на экране) и <b>wait</b> – ждать указанное количество миллисекунд. <b>brick</b> – основной объект, обеспечивающий взаимодействие скрипта с контроллером, вся работа с операционной системой и аппаратным обеспечением контроллера выполняется через него. Он же предоставляет доступ к другим объектам, отвечающим за конкретные устройства, например, обращение к мотору на порту M1 выглядит так:
			</p>
			
			<pre>brick.motor("M1").setPower(100);</pre>
			
			<p>
			Пример более сложной программы, движение по линии с двумя сенсорами света:
			</p>
			
			<pre>
var k = 0.4;
var power = 75;

while (true) {
        var deltaLeft = brick.sensor("A1").read();
        var deltaRight = brick.sensor("A2").read();
        var u = k * (deltaLeft - deltaRight);
        brick.powerMotor("M1").setPower(power + u);
        brick.powerMotor("M2").setPower(-power + u);
}</pre>

			<p>
			Здесь видны объявления переменных – тип для них не указывается, он соответствует значениям, помещаемым в переменную.
			</p>
			
			<p>
			Одно из расширений стандартного ECMAScript, реализованное в Qt Script – возможность подписываться на события. Делается это с помощью функции connect, вызываемой от объекта-события, как в примере ниже. Там с помощью анонимной функции (описываемой с помощью ключевого слова <b>function</b>) скрипт подписывается на событие <b>pad</b>, соответствующее нажатию на одну из активных областей Android-пульта. На пульте их всего две, на какую именно из них нажали передаётся в параметре padId сигнала. <b>x</b> и <b>y</b> – координаты точки нажатия. Функция будет вызываться каждый раз, когда пользователь Android-пульт будет присылать сообщение, что на него нажали. 
			</p>
			
			<pre>
brick.gamepad().pad.connect(
	function(padId, x, y) {
		if (padId == 1) {
			brick.motor("E1").setPower(y);
			brick.motor("E2").setPower(-x);
		}

		if (padId == 2) {
			brick.motor("M1").setPower(y + x);
			brick.motor("M2").setPower(y - x);
		}
	}
)</pre>
	
			<p>
			Подобный стиль программирования называется реактивным (система реагирует на события) и пока не поддержан при генерации по диаграмме из TRIKStudio. То есть генерируемый код никогда не содержит вызовов <b>connect</b>, реактивные программы можно писать только вручную. Для того, чтобы программа не завершилась сразу же, а осталась работать и ожидать событий, используется метод <b>run</b> класса <b>brick</b>. Для выхода из режима ожидания и завершения работы событийно-ориентированного скрипта используется метод <b>stop</b> класса <b>brick</b>. Пример полной событийно-ориентированной программы, которая ждёт нажатия на кнопку "Ввод" и выходит, приведён ниже.
			</p>
			
						<pre>
brick.keys().buttonPressed.connect(
  function(code, value) {
    if (code == KeysEnum.Enter && value == 1) {
      print("'Enter' pressed, exiting");
      brick.quit();
    }
  }
);

brick.run();</pre>

			<p>
			Список доступных методов и событий по классам приведён в таблице ниже.
			</p>
			
			<h5><a name="textual-programming-qts-brick">Класс "Brick"</a></h5>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>playSound</td>
					<td>brick.playSound('media/sound.mp3');</td>
					<td>Проиграть звуковой файл. Принимает в качестве параметра имя файла, который должен быть предварительно загружен на робот (с путём, абсолютным или относительно папки trik на роботе).</td>
				</tr>
				<tr>
					<td>say</td>
					<td>brick.say('Привет, я ТРИК');</td>
					<td>Произнести переданную как параметр строку (на русском или английском языке).</td>
				</tr>
				<tr>
					<td>stop</td>
					<td>brick.stop();</td>
					<td>Останавливает все моторы и активные датчики (такие как датчик линии или датчик объекта), убирает нарисованное на дисплее.</td>
				</tr>
				<tr>
					<td>motor</td>
					<td>brick.motor("M1");</td>
					<td>Возвращает мотор (класс Motor, силовой или сервомотор) на указанном порту.</td>
				</tr>
				<tr>
					<td>sensor</td>
					<td>brick.sensor("A1");</td>
					<td>Возвращает сенсор (класс Sensor) на указанном порту.</td>
				</tr>
				<tr>
					<td>accelerometer</td>
					<td>brick.accelerometer();</td>
					<td>Возвращает акселерометр (класс Sensor3d).</td>
				</tr>
				<tr>
					<td>gyroscope</td>
					<td>brick.gyroscope();</td>
					<td>Возвращает гироскоп (класс Sensor3d).</td>
				</tr>
				<tr>
					<td>lineSensor</td>
					<td>brick.lineSensor();</td>
					<td>Возвращает датчик линии по видеокамере (класс LineSensor).</td>
				</tr>
				<tr>
					<td>colorSensor</td>
					<td>brick.colorSensor();</td>
					<td>Возвращает датчик цвета по видеокамере (класс ColorSensor).</td>
				</tr>
				<tr>
					<td>objectSensor</td>
					<td>brick.objectSensor();</td>
					<td>Возвращает датчик объекта по видеокамере (класс ObjectSensor).</td>
				</tr>
				<tr>
					<td>encoder</td>
					<td>brick.encoder('B1');</td>
					<td>Возвращает энкодер на указанном порту (класс Encoder).</td>
				</tr>
				<tr>
					<td>battery</td>
					<td>brick.battery();</td>
					<td>Возвращает объект, предоставляющий доступ к батарее (класс Battery).</td>
				</tr>
				<tr>
					<td>keys</td>
					<td>brick.keys();</td>
					<td>Возвращает объект, предоставляющий доступ к кнопкам на корпусе робота (класс Keys).</td>
				</tr>
				<tr>
					<td>gamepad</td>
					<td>brick.gamepad();</td>
					<td>Возвращает объект, предоставляющий доступ к Android-пульту (класс Gamepad).</td>
				</tr>
				<tr>
					<td>timer</td>
					<td>brick.timer(100);</td>
					<td>Создаёт и возвращает таймер (класс QTimer), посылающий сигнал timeout каждые n миллисекунд, где n передаётся в качестве параметра.</td>
				</tr>
				<tr>
					<td>wait</td>
					<td>brick.wait(1000);</td>
					<td>Приостанавливает выполнение скрипта на переданное количество миллисекунд.</td>
				</tr>
				<tr>
					<td>time</td>
					<td>brick.time();</td>
					<td>Возвращает временной штамп (число, количество миллисекунд, прошедших с начала 1 января 1970 года по Гринвичу).</td>
				</tr>
				<tr>
					<td>display</td>
					<td>brick.display();</td>
					<td>Возвращает объект, предоставляющий доступ к дисплею робота (класс Display).</td>
				</tr>
				<tr>
					<td>led</td>
					<td>brick.led();</td>
					<td>Возвращает объект, предоставляющий доступ к светодиоду на корпусе робота (класс Led).</td>
				</tr>
				<tr>
					<td>mailbox</td>
					<td>brick.mailbox();</td>
					<td>Возвращает объект, предоставляющий доступ к функциональности "почтовых ящиков" (класс Mailbox).</td>
				</tr>
				<tr>
					<td>run</td>
					<td>brick.run();</td>
					<td>Устанавливает флаг событийно-ориентированной программы. По окончанию работы скрипт не выгружается из памяти, а продолжает ждать наступления событий до тех пор, пока какой-либо из обработчиков не вызовет brick.quit()</td>
				</tr>				
				<tr>
					<td>quit</td>
					<td>brick.quit();</td>
					<td>Устанавливает флаг окончания работы для событийно-ориентированной программы. Как только будет завершён текущий обработчик события, исполнение скрипта закончится.</td>
				</tr>
				<tr>
					<td>system</td>
					<td>brick.system("reboot");</td>
					<td>Выполняет переданную в качестве параметра команду консоли операционной системы.</td>
				</tr>				
			</table>
			
			<h5><a name="textual-programming-qts-battery">Класс "Battery"</a></h5>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>readVoltage</td>
					<td>brick.battery().readVoltage();</td>
					<td>Возвращает текущий вольтаж батареи (или блока питания) в вольтах.</td>
				</tr>	
			</table>
			
			<h5><a name="textual-programming-qts-colorSensor">Класс "ColorSensor"</a></h5>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>init</td>
					<td>brick.colorSensor().init(true);</td>
					<td>Включает видеокамеру и инициализирует её в режиме датчика цвета. Булевый параметр определяет, выводить ли на экран изображение с камеры (true – выводить).</td>
				</tr>
				<tr>
					<td>read</td>
					<td>brick.colorSensor().read(2, 2);</td>
					<td>Возвращает массив с координатами доминирующего цвета в цветовой шкале RGB в указанном участке кадра. Кадр делится на квадраты сеткой, по умолчанию 3 на 3, размерность сетки можно задать в config.xml на роботе. Квадраты индексируются с 1, то есть (1, 1) – это левый верхний край кадра, (2, 2) – его центр. Возвращаемое значение – массив из трёх элементов от 0 до 255, индексирующийся с 0. Нулевой элемент содержит интенсивность красного (0 – совсем нет, 255 – очень много), первый – интенсивность зелёного, второй – интенсивность синего. Например, (0, 0, 0) – чёрный, (255, 255, 255) – белый, (255, 0, 0) – красный.</td>
				</tr>
				<tr>
					<td>stop</td>
					<td>brick.colorSensor().stop();</td>
					<td>Выключает видеокамеру и прекращает работу датчика.</td>
				</tr>
			</table>
			
			<h5><a name="textual-programming-qts-lineSensor">Класс "LineSensor"</a></h5>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>init</td>
					<td>brick.lineSensor().init(true);</td>
					<td>Включает видеокамеру и инициализирует её в режиме датчика линии. Булевый параметр определяет, выводить ли на экран изображение с камеры (true – выводить).</td>
				</tr>
				<tr>
					<td>detect</td>
					<td>brick.lineSensor().detect();</td>
					<td>Определяет доминирующий цвет в вертикальной полосе в центре кадра и запоминает его как цвет линии. После этого read() начинает возвращать данные для этой линии.</td>
				</tr>
				<tr>
					<td>read</td>
					<td>brick.lineSensor().read();</td>
					<td>Возвращает массив, в ячейках которого находятся следующие данные: 
					<ul>
						<li>в нулевой ячейке координата по оси x центра линии относительно центра кадра (от -100 до 100, -100 – центр линии на краю кадра слева);</li>
						<li>в первой ячейке – вероятность перекрёстка (число от 0 до 100, показывающее сколько точек цвета линии находится в горизонтальной полосе в центре кадра);</li>
						<li>во второй ячейке – относительный размер линии, число от 0 до 100. 100 – линия занимает почти весь кадр, 0 – линии нет на кадре.</li>
					</ul>
					</td>
				</tr>
				<tr>
					<td>stop</td>
					<td>brick.lineSensor().stop();</td>
					<td>Выключает видеокамеру и прекращает работу датчика.</td>
				</tr>
			</table>
			
			<h5><a name="textual-programming-qts-objectSensor">Класс "ObjectSensor"</a></h5>

			<table cellspacing="2" border="1" cellpadding="5" width="800" >
				<tr>
					<td><b>Название метода</b></td>
					<td><b>Пример вызова</b></td>
					<td><b>Описание</b></td>
				</tr>
				<tr>
					<td>init</td>
					<td>brick.objectSensor().init(true);</td>
					<td>Включает видеокамеру и инициализирует её в режиме датчика объекта. Булевый параметр определяет, выводить ли на экран изображение с камеры (true – выводить).</td>
				</tr>
				<tr>
					<td>detect</td>
					<td>brick.objectSensor().detect();</td>
					<td>Определяет доминирующий цвет в центре кадра и запоминает его как цвет объекта. После этого read() начинает возвращать данные для объекта.</td>
				</tr>
				<tr>
					<td>read</td>
					<td>brick.objectSensor().read();</td>
					<td>Возвращает массив, в ячейках которого находятся следующие данные: 
					<ul>
						<li>в нулевой ячейке координата по оси x центра объекта относительно центра кадра (от -100 до 100, -100 – центр объекта на краю кадра слева);</li>
						<li>в первой ячейке – координата по оси y центра объекта относительно центра кадра (от -100 до 100, -100 – центр объекта на краю кадра сверху);</li>
						<li>во второй ячейке – относительный размер объекта, число от 0 до 100. 100 – объекта занимает почти весь кадр, 0 – объекта нет на кадре.</li>
					</ul>
					</td>
				</tr>
				<tr>
					<td>stop</td>
					<td>brick.objectSensor().stop();</td>
					<td>Выключает видеокамеру и прекращает работу датчика.</td>
				</tr>
			</table>

			<h4><a name="textual-programming-fsharp">F#</a></h4>
		</div>
		<!-- end #content -->
		<div style="clear: both;">&nbsp;</div>
	</div>
	<!-- end #page -->
</div>
<script type="text/javascript" src="footer.html.js"></script>
</body>
</html>
