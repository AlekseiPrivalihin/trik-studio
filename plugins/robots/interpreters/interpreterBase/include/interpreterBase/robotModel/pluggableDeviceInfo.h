#pragma once

#include <QtCore/QString>
#include <QtCore/QMap>
#include <QtCore/QMetaObject>

namespace interpreterBase {
namespace robotModel {

/// Describes a type of a pluggable device, not a concrete instance of it.
/// Given a set of PluggableDeviceInfo corresponding to some pluggable devices
/// hierarchy original inheritance relations can be recovered with isA() method.
class PluggableDeviceInfo
{
public:
	/// Creates a new instance of a PluggableDevice descriptor. The resulting object will
	/// correspond to a given type only if Q_OBJECT macro is used inside its declaration.
	template <typename T>
	static PluggableDeviceInfo create(QString const &friendlyName = QString())
	{
		// This line performs Q_OBJECT macro checking in the given type declaration.
		// Without Q_OBJECT macro incorrect metaObject will be passed and it will lead
		// to invalid isA() method work.
		static_assert(HasQObjectMacro<T>::Value, "No Q_OBJECT macro in the class that is passed into a template");
		QMetaObject const *metaObject = &T::staticMetaObject;
		PluggableDeviceInfo result(metaObject, friendlyName);
		mCreatedInfos[QString(metaObject->className())] = result;
		return result;
	}

	/// Deserializes inner string representation obtained by toString()
	static PluggableDeviceInfo fromString(QString const &string);

	/// Constructs invalid PluggableDeviceInfo instance
	PluggableDeviceInfo();

	/// Serializes given pluggable device info into inner string representation
	QString toString() const;

	/// Returns if the device corresponding to 'this' inherits a 'parent' one or they are the devices of the same type.
	bool isA(PluggableDeviceInfo const &parent) const;

	/// Returns a string that can be displayed to a user as the name of the pluggable device.
	QString friendlyName() const;

private:
	/// Trait that tells if the Object has a Q_OBJECT macro.
	template <typename Object>
	struct HasQObjectMacro
	{
		// Following two overloads will return int if qt_metacall function (generated by Q_OBJECT macro)
		// belongs to 'Object' type (and so Q_OBJECT macro is placed there) and char otherwise.
		template <typename T>
		static char returnIntIfHasQObjectMacro(int (T::*)(QMetaObject::Call, int, void **));
		static int returnIntIfHasQObjectMacro(int (Object::*)(QMetaObject::Call, int, void **));

		// Enum is used for forcing compiler evaluating below expression on compile-time
		enum { Value = sizeof(returnIntIfHasQObjectMacro(&Object::qt_metacall)) == sizeof(int) };
	};

	friend bool operator ==(PluggableDeviceInfo const &device1, PluggableDeviceInfo const &device2);
	friend bool operator !=(PluggableDeviceInfo const &device1, PluggableDeviceInfo const &device2);

	explicit PluggableDeviceInfo(QMetaObject const *deviceType, QString const &friendlyName);

	static QMap<QString, PluggableDeviceInfo> mCreatedInfos;

	QMetaObject const *mDeviceType;
	QString mFriendlyName;
};

inline bool operator ==(PluggableDeviceInfo const &device1, PluggableDeviceInfo const &device2)
{
	return QString(device1.mDeviceType->className()) == QString(device2.mDeviceType->className());
}

inline bool operator !=(PluggableDeviceInfo const &device1, PluggableDeviceInfo const &device2)
{
	return !(device1 == device2);
}

}
}
